# **Project Legalis-RS: The Architecture of Generative Jurisprudence**

## **～Separating Law and Narrative: A Blueprint for "Governance as Code"～**

Version: 0.2.0 (Standalone Edition)  
Language: Rust (Edition 2024\)  
License: MIT / Apache 2.0 (Open Source)  
Core Philosophy: "Governance as Code, Justice as Narrative"

## **1\. Executive Summary**

**Legalis-RS** is a Rust-based framework for rigorously separating and structuring laws, contracts, and rules written in natural language into **"deterministic logic (Code)"** and **"discretionary narratives (Narrative)"**.

This project aims to be **self-contained** by leveraging Rust's standard ecosystem without relying on specific external tools, achieving the following:

1. **Debug Jurisprudence:** Detect logical contradictions (bugs) in legislation as compile-time errors.  
2. **Simulation Jurisprudence:** Rapidly verify social impacts on digital twins before law enforcement.  
3. **Automated Soft ODA:** "Port" the kernel of Japanese law to other countries' cultures and languages.

## **2\. System Architecture (Workspace Structure)**

We leverage Rust's Workspace feature for monorepo development. Connections to external services (such as LLMs) are abstracted through the adapter pattern, designed to be vendor-agnostic.

\[workspace\]  
members \= \[  
    "crates/legalis-core",      \# Type definitions, state management, common traits  
    "crates/legalis-dsl",       \# Legal description language (Parser / AST / Macro)  
    "crates/legalis-llm",       \# LLM integration (abstraction layer)  
    "crates/legalis-sim",       \# Simulation (ECS engine)  
    "crates/legalis-verifier",  \# Formal verification (SMT Solver integration)  
    "crates/legalis-chain",     \# Smart Contract Export (WASM/Solidity)  
\]

\[workspace.dependencies\]  
serde \= { version \= "1.0", features \= \["derive"\] }  
serde\_json \= "1.0"  
tokio \= { version \= "1.0", features \= \["full"\] }  
anyhow \= "1.0"  
uuid \= { version \= "1.0", features \= \["v4"\] }  
reqwest \= { version \= "0.11", features \= \["json"\] } \# For LLM API calls  
async-trait \= "0.1"

## **3\. Core Module: Type Definition of "Ambiguity"**

This is the philosophical core of the project.  
By **not making everything computable**, we prevent AI theocracy (dystopia). The domain requiring human judgment is explicitly preserved as the JudicialDiscretion type.

### **crates/legalis-core/src/lib.rs**

use serde::{Deserialize, Serialize};  
use uuid::Uuid;

/// Algebraic Data Type (ADT) representing the result of a legal judgment  
\#\[derive(Debug, Clone, Serialize, Deserialize)\]  
pub enum LegalResult\<T\> {  
    /// 【Deterministic Domain】  
    /// Result automatically derived through computation.  
    /// (e.g., age requirements, income limits, deadline calculations)  
    Deterministic(T),

    /// 【Discretionary Domain】  
    /// A domain that cannot be determined by logic alone and requires human "narrative (interpretation)".  
    /// This is the bulwark against "AI theocracy".  
    /// The system stops here and throws the ball to humans.  
    JudicialDiscretion {  
        /// Issue (e.g., "presence of just cause", "violation of public welfare")  
        issue: String,  
        /// Contextual data to be referenced  
        context\_id: Uuid,  
        /// Recommended judgment materials (generated by LLM, but does not decide)  
        narrative\_hint: Option\<String\>,  
    },

    /// 【Logical Breakdown】  
    /// Bug in the law itself.  
    Void { reason: String },  
}

/// Legal entity (natural person, legal person, or AI agent)  
pub trait LegalEntity {  
    fn id(\&self) \-\> Uuid;  
    fn get\_attribute(\&self, key: \&str) \-\> Option\<String\>;  
}

/// Definition of a Statute  
\#\[derive(Debug, Clone, Serialize, Deserialize)\]  
pub struct Statute {  
    pub id: String,  
    pub title: String,  
    /// Application requirements (If)  
    pub preconditions: Vec\<Condition\>,  
    /// Legal effect (Then)  
    pub effect: Effect,  
    /// Discretionary logic (Else If Maybe)  
    pub discretion\_logic: Option\<String\>,   
}

// Placeholder for common type definitions  
\#\[derive(Debug, Clone, Serialize, Deserialize)\]  
pub struct Condition { /\* ... \*/ }  
\#\[derive(Debug, Clone, Serialize, Deserialize)\]  
pub struct Effect { /\* ... \*/ }

## **4\. LLM Module: Universal "Intelligence Adapter"**

Designed to be independent of specific LLM orchestrators, allowing any AI model (OpenAI, Anthropic, Gemini, Local LLM) to be pluggable through the LLMProvider trait.

### **crates/legalis-llm/src/lib.rs**

use async\_trait::async\_trait;  
use anyhow::Result;

/// Abstraction trait for LLM providers  
\#\[async\_trait\]  
pub trait LLMProvider {  
    /// Receives a prompt and returns a text response  
    async fn generate\_text(\&self, prompt: \&str) \-\> Result\<String\>;  
      
    /// Forces conversion to structured data (JSON, etc.)  
    async fn generate\_structured\<T: serde::de::DeserializeOwned\>(\&self, prompt: \&str) \-\> Result\<T\>;  
}

/// Concrete implementation example: OpenAI (or compatible API)  
pub struct OpenAiClient {  
    api\_key: String,  
    model: String,  
    client: reqwest::Client,  
}

impl OpenAiClient {  
    pub fn new(api\_key: String, model: String) \-\> Self {  
        Self {  
            api\_key,  
            model,  
            client: reqwest::Client::new(),  
        }  
    }  
}

\#\[async\_trait\]  
impl LLMProvider for OpenAiClient {  
    async fn generate\_text(\&self, prompt: \&str) \-\> Result\<String\> {  
        // Implement actual request logic here  
        // Use reqwest to call API endpoint  
        Ok("Mock response for now".to\_string())  
    }

    async fn generate\_structured\<T: serde::de::DeserializeOwned\>(\&self, prompt: \&str) \-\> Result\<T\> {  
        let text \= self.generate\_text(prompt).await?;  
        // JSON parsing  
        let data \= serde\_json::from\_str(\&text)?;  
        Ok(data)  
    }  
}

### **crates/legalis-llm/src/compiler.rs**

use crate::LLMProvider;  
use legalis\_core::Statute;  
use anyhow::Result;

pub struct LawCompiler\<P: LLMProvider\> {  
    provider: P,  
}

impl\<P: LLMProvider\> LawCompiler\<P\> {  
    pub fn new(provider: P) \-\> Self {  
        Self { provider }  
    }

    /// Convert natural language statutes to Rust code (AST)  
    pub async fn compile(\&self, raw\_text: \&str) \-\> Result\<Statute\> {  
        let system\_prompt \= "You are a 'Legal Compiler'. Convert natural language statutes into Rust structures. Any part subject to interpretation must be marked as 'JudicialDiscretion'.";  
        let prompt \= format\!("{}\\n\\nAnalyze the following statute: {}", system\_prompt, raw\_text);

        // Get structured data via provider  
        self.provider.generate\_structured(\&prompt).await  
    }  
}

## **5\. Sim Module: In-Memory Parallel Simulation**

Build a simple yet fast ECS (Entity Component System)-like simulator using Rust's standard asynchronous runtime (Tokio) and channels, without relying on external task queue systems.

### **crates/legalis-sim/src/engine.rs**

use tokio::sync::mpsc;  
use legalis\_core::{Statute, LegalEntity, LegalResult, Effect};  
use std::sync::Arc;

/// Simulation engine  
pub struct SimEngine {  
    /// Bills to be simulated  
    statutes: Vec\<Statute\>,  
    /// Citizen agents (shared via Arc for parallel processing)  
    population: Vec\<Arc\<dyn LegalEntity \+ Send \+ Sync\>\>,  
}

impl SimEngine {  
    pub fn new(statutes: Vec\<Statute\>, population: Vec\<Box\<dyn LegalEntity \+ Send \+ Sync\>\>) \-\> Self {  
        Self {  
            statutes,  
            population: population.into\_iter().map(Arc::from).collect(),  
        }  
    }

    /// Execute simulation  
    pub async fn run\_simulation(\&self) {  
        let (tx, mut rx) \= mpsc::channel(1000);

        println\!("Starting simulation with {} agents...", self.population.len());

        for agent in \&self.population {  
            let agent\_ref \= agent.clone();  
            let statutes\_ref \= self.statutes.clone();  
            let tx\_clone \= tx.clone();

            // Execute in parallel as Tokio task  
            tokio::spawn(async move {  
                for statute in statutes\_ref {  
                    let result \= Self::apply\_law(agent\_ref.as\_ref(), \&statute);  
                    // Send result to receiver  
                    let \_ \= tx\_clone.send((agent\_ref.id(), statute.id, result)).await;  
                }  
            });  
        }

        // Drop sender to allow receive loop to terminate  
        drop(tx);

        // Aggregate results  
        while let Some((agent\_id, statute\_id, result)) \= rx.recv().await {  
            match result {  
                LegalResult::Deterministic(\_) \=\> {  
                    // Add to statistical data  
                }  
                LegalResult::JudicialDiscretion { issue, .. } \=\> {  
                    println\!("Conflict detected for Agent {}: Law {} \-\> {}", agent\_id, statute\_id, issue);  
                }  
                \_ \=\> {}  
            }  
        }  
    }

    fn apply\_law(agent: &(dyn LegalEntity \+ Send \+ Sync), law: \&Statute) \-\> LegalResult\<Effect\> {  
        // Law application logic (requirement judgment \-\> effect occurrence)  
        // In practice, call logic from legalis-core  
          
        // Temporary implementation: simulation of cases requiring discretion  
        if law.discretion\_logic.is\_some() {  
             return LegalResult::JudicialDiscretion {  
                issue: "Discretion required".to\_string(),  
                context\_id: agent.id(),  
                narrative\_hint: None,  
            };  
        }  
          
        // Temporary implementation: deterministic  
        LegalResult::Deterministic(law.effect.clone())  
    }  
}

## **6\. Verifier Module: Formal Verification**

A static analyzer to prevent "buggy laws" from being released to the world.  
Calls Z3 (SMT Solver) from Rust to check for logical contradictions.

### **crates/legalis-verifier/src/lib.rs**

// Conceptual code  
// Assumes use of z3 crate or similar  
pub fn verify\_integrity(laws: &\[Statute\]) \-\> Result\<(), String\> {  
    // 1\. Circular reference check  
    // Graph search to check if statute A's requirements depend on statute B, and B doesn't depend on A

    // 2\. Deadlock check  
    // Check for "dead statutes" that can never be True regardless of input (citizen attributes)

    // 3\. Constitutional compatibility check  
    // Check for paths that logically contradict (A and Not A) higher regulations (Constitution)  
      
    // Implement conversion logic to Z3 Solver here  
    Ok(())  
}

## **7\. Use Cases and Roadmap**

Phases for social implementation that this project aims to achieve.

### **Phase 1: "The Visualizer" (Visualization)**

* **Target:** Local government ordinances.  
* **Action:** Input complex "subsidy eligibility requirements" into Legalis-RS.  
* **Output:** Automatically generate a decision tree showing "who qualifies and who doesn't," visualized as a flowchart. Highlight "interpretatively ambiguous gray zones" in red.

### **Phase 2: "The Debugger" (Diet DX)**

* **Target:** New bill creation process.  
* **Action:** Compile bill text written by bureaucrats via LLM.  
* **Output:** Verifier runs and warns "Article X and Article Y are logically contradictory (compile error)."

### **Phase 3: "The Soft ODA" (Legal System Export)**

* **Target:** Legal development assistance for developing countries.  
* **Action:** Based on Japanese Commercial Code (J-Kernel), inject local cultural parameters (religious taboos, etc.).  
* **Output:** Automatically generate a "localized Commercial Code" written in local language and logically consistent.

### **Phase 4: "The Hybrid Court" (Semi-Automated Trials)**

* **Target:** Small claims litigation and administrative procedures.  
* **Action:** LegalResult::Deterministic cases are immediately auto-processed (executed on blockchain).  
* **Human Loop:** Only cases returning JudicialDiscretion are referred to human judges/mediators. This allows humans to focus solely on "creative interpretation (weaving narratives)."

## **8\. Conclusion: Message to the Engineering Team**

"Code is Law," they say, but we take the approach of "Law becomes Code."  
However, we embed a type called 'Humanity' into that code.

Legalis-RS is a pure Rust Native legal kernel that does not depend on external black boxes.  
By designing LLMs and simulation infrastructure as pluggable modules, we avoid vendor lock-in and aim for the robustness to withstand national-level infrastructure.  
Let's start with cargo new legalis-rs \--workspace.  
The time has come to implement the dream of UML from 20 years ago in Rust.