//! Singapore Interoperability Module.
//!
//! This module provides integration with the L4 DSL, a Singapore legal DSL
//! developed by SMU CCLAW (Centre for Computational Law) with deontic logic support.
//!
//! ## L4 Integration
//!
//! L4 (Law Language Logical Language) is designed for computational representation
//! of Singapore legislation, including:
//! - Companies Act (Cap. 50)
//! - Employment Act (Cap. 91)
//! - PDPA (Personal Data Protection Act)
//! - Consumer Protection (Fair Trading) Act
//!
//! This module enables:
//! - Import: Parse L4 source code into Legalis statutes
//! - Export: Convert Legalis statutes to L4 format
//! - Roundtrip: Validate semantic preservation through conversion

use legalis_core::Statute;
use legalis_interop::{
    ConversionReport, InteropResult, LegalConverter, LegalFormat, SemanticValidation,
};

// ============================================================================
// Singapore L4 Integration
// ============================================================================

/// Singapore-specific L4 converter with enhanced support for Singapore legal acts
pub struct SingaporeL4Converter {
    converter: LegalConverter,
    deontic_mode: DeonticMode,
}

/// Deontic logic mode for L4
#[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]
pub enum DeonticMode {
    /// Standard deontic operators (MUST, MAY, SHANT)
    #[default]
    Standard,
    /// Extended deontic operators with defeasibility
    Extended,
    /// Strict interpretation
    Strict,
}

impl Default for SingaporeL4Converter {
    fn default() -> Self {
        Self::new()
    }
}

impl SingaporeL4Converter {
    /// Creates a new Singapore L4 converter
    pub fn new() -> Self {
        Self {
            converter: LegalConverter::with_cache(100),
            deontic_mode: DeonticMode::default(),
        }
    }

    /// Creates a converter with specific deontic mode
    pub fn with_deontic_mode(mode: DeonticMode) -> Self {
        Self {
            converter: LegalConverter::with_cache(100),
            deontic_mode: mode,
        }
    }

    /// Returns the current deontic mode
    pub fn deontic_mode(&self) -> DeonticMode {
        self.deontic_mode
    }

    /// Imports L4 source code into Legalis statutes
    pub fn import_l4(&mut self, source: &str) -> InteropResult<(Vec<Statute>, ConversionReport)> {
        let (mut statutes, mut report) = self.converter.import(source, LegalFormat::L4)?;

        // Add Singapore jurisdiction to all imported statutes
        for statute in &mut statutes {
            if statute.jurisdiction.is_none() {
                statute.jurisdiction = Some("SG".to_string());
            }
        }

        // Add Singapore-specific metadata
        report.warnings.push(format!(
            "Imported with {:?} deontic mode",
            self.deontic_mode
        ));

        Ok((statutes, report))
    }

    /// Exports Legalis statutes to L4 format
    pub fn export_to_l4(
        &mut self,
        statutes: &[Statute],
    ) -> InteropResult<(String, ConversionReport)> {
        let (mut output, report) = self.converter.export(statutes, LegalFormat::L4)?;

        // Add Singapore law header
        let header = format!(
            "-- Generated by Legalis-RS\n-- Jurisdiction: Singapore\n-- Deontic Mode: {:?}\n\n",
            self.deontic_mode
        );
        output = header + output.as_str();

        Ok((output, report))
    }

    /// Converts L4 to other legal DSL formats
    pub fn convert_from_l4(
        &mut self,
        source: &str,
        target: LegalFormat,
    ) -> InteropResult<(String, ConversionReport)> {
        self.converter.convert(source, LegalFormat::L4, target)
    }

    /// Converts other legal DSL formats to L4
    pub fn convert_to_l4(
        &mut self,
        source: &str,
        from: LegalFormat,
    ) -> InteropResult<(String, ConversionReport)> {
        self.converter.convert(source, from, LegalFormat::L4)
    }

    /// Validates roundtrip conversion fidelity
    pub fn validate_roundtrip(
        &mut self,
        source: &str,
        target: LegalFormat,
    ) -> InteropResult<SemanticValidation> {
        self.converter
            .validate_roundtrip(source, LegalFormat::L4, target)
    }
}

// ============================================================================
// Companies Act Converter
// ============================================================================

/// Specialized converter for Companies Act (Cap. 50) provisions
pub struct CompaniesActConverter {
    converter: SingaporeL4Converter,
}

impl Default for CompaniesActConverter {
    fn default() -> Self {
        Self::new()
    }
}

impl CompaniesActConverter {
    /// Creates a new Companies Act converter
    pub fn new() -> Self {
        Self {
            converter: SingaporeL4Converter::new(),
        }
    }

    /// Imports Companies Act provisions from L4
    pub fn import_companies_act(
        &mut self,
        source: &str,
    ) -> InteropResult<(Vec<Statute>, ConversionReport)> {
        let (mut statutes, mut report) = self.converter.import_l4(source)?;

        // Tag all statutes as Companies Act
        for statute in &mut statutes {
            statute
                .effect
                .parameters
                .insert("source_act".to_string(), "Companies Act".to_string());
            statute
                .effect
                .parameters
                .insert("cap_number".to_string(), "50".to_string());
        }

        report
            .warnings
            .push("Imported from Companies Act (Cap. 50)".to_string());

        Ok((statutes, report))
    }

    /// Exports to L4 format with Companies Act header
    pub fn export_companies_act(
        &mut self,
        statutes: &[Statute],
    ) -> InteropResult<(String, ConversionReport)> {
        let (mut output, report) = self.converter.export_to_l4(statutes)?;

        // Add Companies Act reference header
        output = format!(
            "-- Companies Act (Cap. 50)\n-- Republic of Singapore\n-- Source: https://sso.agc.gov.sg\n\n{}",
            output
        );

        Ok((output, report))
    }
}

// ============================================================================
// Employment Act Converter
// ============================================================================

/// Specialized converter for Employment Act (Cap. 91) provisions
pub struct EmploymentActConverter {
    converter: SingaporeL4Converter,
}

impl Default for EmploymentActConverter {
    fn default() -> Self {
        Self::new()
    }
}

impl EmploymentActConverter {
    /// Creates a new Employment Act converter
    pub fn new() -> Self {
        Self {
            converter: SingaporeL4Converter::new(),
        }
    }

    /// Imports Employment Act provisions from L4
    pub fn import_employment_act(
        &mut self,
        source: &str,
    ) -> InteropResult<(Vec<Statute>, ConversionReport)> {
        let (mut statutes, mut report) = self.converter.import_l4(source)?;

        // Tag all statutes as Employment Act
        for statute in &mut statutes {
            statute
                .effect
                .parameters
                .insert("source_act".to_string(), "Employment Act".to_string());
            statute
                .effect
                .parameters
                .insert("cap_number".to_string(), "91".to_string());
            statute
                .effect
                .parameters
                .insert("domain".to_string(), "employment".to_string());
        }

        report
            .warnings
            .push("Imported from Employment Act (Cap. 91)".to_string());

        Ok((statutes, report))
    }

    /// Exports to L4 format with Employment Act header
    pub fn export_employment_act(
        &mut self,
        statutes: &[Statute],
    ) -> InteropResult<(String, ConversionReport)> {
        let (mut output, report) = self.converter.export_to_l4(statutes)?;

        // Add Employment Act reference header
        output = format!(
            "-- Employment Act (Cap. 91)\n-- Republic of Singapore\n-- Source: https://sso.agc.gov.sg\n\n{}",
            output
        );

        Ok((output, report))
    }
}

// ============================================================================
// PDPA Converter
// ============================================================================

/// Specialized converter for Personal Data Protection Act (PDPA)
pub struct PdpaConverter {
    converter: SingaporeL4Converter,
}

impl Default for PdpaConverter {
    fn default() -> Self {
        Self::new()
    }
}

impl PdpaConverter {
    /// Creates a new PDPA converter
    pub fn new() -> Self {
        Self {
            converter: SingaporeL4Converter::new(),
        }
    }

    /// Imports PDPA provisions from L4
    pub fn import_pdpa(&mut self, source: &str) -> InteropResult<(Vec<Statute>, ConversionReport)> {
        let (mut statutes, mut report) = self.converter.import_l4(source)?;

        // Tag all statutes as PDPA
        for statute in &mut statutes {
            statute.effect.parameters.insert(
                "source_act".to_string(),
                "Personal Data Protection Act 2012".to_string(),
            );
            statute
                .effect
                .parameters
                .insert("domain".to_string(), "data_protection".to_string());
        }

        report
            .warnings
            .push("Imported from Personal Data Protection Act 2012".to_string());

        Ok((statutes, report))
    }

    /// Exports to L4 format with PDPA header
    pub fn export_pdpa(
        &mut self,
        statutes: &[Statute],
    ) -> InteropResult<(String, ConversionReport)> {
        let (mut output, report) = self.converter.export_to_l4(statutes)?;

        // Add PDPA reference header
        output = format!(
            "-- Personal Data Protection Act 2012\n-- Republic of Singapore\n-- Source: https://sso.agc.gov.sg\n\n{}",
            output
        );

        Ok((output, report))
    }
}

// ============================================================================
// Consumer Protection Converter
// ============================================================================

/// Specialized converter for Consumer Protection (Fair Trading) Act
pub struct ConsumerProtectionConverter {
    converter: SingaporeL4Converter,
}

impl Default for ConsumerProtectionConverter {
    fn default() -> Self {
        Self::new()
    }
}

impl ConsumerProtectionConverter {
    /// Creates a new Consumer Protection converter
    pub fn new() -> Self {
        Self {
            converter: SingaporeL4Converter::new(),
        }
    }

    /// Imports Consumer Protection provisions from L4
    pub fn import_cpfta(
        &mut self,
        source: &str,
    ) -> InteropResult<(Vec<Statute>, ConversionReport)> {
        let (mut statutes, mut report) = self.converter.import_l4(source)?;

        // Tag all statutes as CPFTA
        for statute in &mut statutes {
            statute.effect.parameters.insert(
                "source_act".to_string(),
                "Consumer Protection (Fair Trading) Act".to_string(),
            );
            statute
                .effect
                .parameters
                .insert("domain".to_string(), "consumer_protection".to_string());
        }

        report
            .warnings
            .push("Imported from Consumer Protection (Fair Trading) Act".to_string());

        Ok((statutes, report))
    }

    /// Exports to L4 format with CPFTA header
    pub fn export_cpfta(
        &mut self,
        statutes: &[Statute],
    ) -> InteropResult<(String, ConversionReport)> {
        let (mut output, report) = self.converter.export_to_l4(statutes)?;

        // Add CPFTA reference header
        output = format!(
            "-- Consumer Protection (Fair Trading) Act\n-- Republic of Singapore\n-- Source: https://sso.agc.gov.sg\n\n{}",
            output
        );

        Ok((output, report))
    }
}

// ============================================================================
// Batch Conversion Utilities
// ============================================================================

/// Batch converts multiple L4 sources to Legalis statutes
pub fn batch_import_l4(sources: &[String]) -> InteropResult<Vec<(Vec<Statute>, ConversionReport)>> {
    let mut converter = SingaporeL4Converter::new();
    let mut results = Vec::with_capacity(sources.len());

    for source in sources {
        match converter.import_l4(source) {
            Ok(result) => results.push(result),
            Err(e) => {
                let mut report = ConversionReport::new(LegalFormat::L4, LegalFormat::Legalis);
                report.add_warning(format!("Import failed: {}", e));
                report.confidence = 0.0;
                results.push((Vec::new(), report));
            }
        }
    }

    Ok(results)
}

/// Batch exports Legalis statutes to L4 format
pub fn batch_export_l4(
    statute_groups: &[Vec<Statute>],
) -> InteropResult<Vec<(String, ConversionReport)>> {
    let mut converter = SingaporeL4Converter::new();
    let mut results = Vec::with_capacity(statute_groups.len());

    for statutes in statute_groups {
        match converter.export_to_l4(statutes) {
            Ok(result) => results.push(result),
            Err(e) => {
                let mut report = ConversionReport::new(LegalFormat::Legalis, LegalFormat::L4);
                report.add_warning(format!("Export failed: {}", e));
                report.confidence = 0.0;
                results.push((String::new(), report));
            }
        }
    }

    Ok(results)
}

// ============================================================================
// L4 Template Generators
// ============================================================================

/// Generates an L4 RULE template
pub fn generate_l4_rule(
    name: &str,
    condition: &str,
    actor: &str,
    deontic: &str,
    action: &str,
) -> String {
    format!(
        "RULE {}\n  WHEN {}\n  THEN {} {} {}",
        to_l4_identifier(name),
        condition,
        actor,
        deontic,
        action
    )
}

/// Generates an L4 DEFINE template
pub fn generate_l4_define(name: &str, definition: &str) -> String {
    format!("DEFINE {}\n  MEANS {}", to_l4_identifier(name), definition)
}

/// Generates an L4 GIVEN/GIVETH template
pub fn generate_l4_given(name: &str, inputs: &[(&str, &str)], outputs: &[(&str, &str)]) -> String {
    let mut template = format!("GIVEN {}\n", to_l4_identifier(name));

    for (var_name, var_type) in inputs {
        template.push_str(&format!("  {} IS A {}\n", var_name, var_type));
    }

    template.push_str("GIVETH\n");

    for (var_name, var_type) in outputs {
        template.push_str(&format!("  {} IS A {}\n", var_name, var_type));
    }

    template
}

/// Generates an L4 DECIDE template
pub fn generate_l4_decide(output: &str, conditions: &[(&str, &str)], default: &str) -> String {
    let mut template = format!("DECIDE {}\n", output);

    for (condition, value) in conditions {
        template.push_str(&format!("  IF {} THEN {}\n", condition, value));
    }

    template.push_str(&format!("  OTHERWISE {}", default));

    template
}

/// Converts a name to a valid L4 identifier (PascalCase for rules, lowercase for variables)
fn to_l4_identifier(name: &str) -> String {
    name.split(|c: char| !c.is_alphanumeric())
        .filter(|s| !s.is_empty())
        .map(|word| {
            let mut chars = word.chars();
            match chars.next() {
                Some(first) => first.to_uppercase().chain(chars).collect::<String>(),
                None => String::new(),
            }
        })
        .collect()
}

// ============================================================================
// SMU CCLAW Integration Helpers
// ============================================================================

/// L4 deontic operators
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum L4DeonticOperator {
    /// MUST - Obligation
    Must,
    /// MAY - Permission
    May,
    /// SHANT - Prohibition
    Shant,
    /// IF...THEN - Conditional
    If,
}

impl L4DeonticOperator {
    /// Returns the L4 keyword for this operator
    pub fn keyword(&self) -> &'static str {
        match self {
            L4DeonticOperator::Must => "MUST",
            L4DeonticOperator::May => "MAY",
            L4DeonticOperator::Shant => "SHANT",
            L4DeonticOperator::If => "IF",
        }
    }

    /// Converts from Legalis EffectType
    pub fn from_effect_type(effect_type: legalis_core::EffectType) -> Self {
        match effect_type {
            legalis_core::EffectType::Obligation => L4DeonticOperator::Must,
            legalis_core::EffectType::Grant => L4DeonticOperator::May,
            legalis_core::EffectType::Prohibition => L4DeonticOperator::Shant,
            _ => L4DeonticOperator::If,
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use legalis_core::{Condition, Effect, EffectType};

    #[test]
    fn test_singapore_l4_converter_creation() {
        let converter = SingaporeL4Converter::new();
        assert_eq!(converter.deontic_mode(), DeonticMode::Standard);
    }

    #[test]
    fn test_singapore_l4_converter_with_mode() {
        let converter = SingaporeL4Converter::with_deontic_mode(DeonticMode::Extended);
        assert_eq!(converter.deontic_mode(), DeonticMode::Extended);
    }

    #[test]
    fn test_l4_import() {
        let mut converter = SingaporeL4Converter::new();

        let l4_source = "RULE VotingAge WHEN age >= 21 THEN Person MAY vote";

        let result = converter.import_l4(l4_source);
        assert!(result.is_ok());

        let (statutes, report) = result.unwrap();
        assert!(!statutes.is_empty());
        assert!(report.statutes_converted >= 1);
    }

    #[test]
    fn test_l4_export() {
        let mut converter = SingaporeL4Converter::new();

        let statute = Statute::new(
            "directors_duty",
            "Directors Duty of Care",
            Effect::new(EffectType::Obligation, "Exercise reasonable diligence"),
        )
        .with_precondition(Condition::AttributeEquals {
            key: "role".to_string(),
            value: "director".to_string(),
        })
        .with_jurisdiction("SG");

        let result = converter.export_to_l4(&[statute]);
        assert!(result.is_ok());

        let (output, report) = result.unwrap();
        assert!(output.contains("RULE"));
        assert!(output.contains("MUST"));
        assert!(report.statutes_converted >= 1);
    }

    #[test]
    fn test_companies_act_converter() {
        let mut converter = CompaniesActConverter::new();

        let l4_source =
            "RULE BoardMeeting WHEN directors_present >= 2 THEN Company MAY pass_resolution";

        let result = converter.import_companies_act(l4_source);
        assert!(result.is_ok());

        let (statutes, _) = result.unwrap();
        for statute in statutes {
            assert_eq!(
                statute.effect.parameters.get("source_act"),
                Some(&"Companies Act".to_string())
            );
        }
    }

    #[test]
    fn test_employment_act_converter() {
        let mut converter = EmploymentActConverter::new();

        let l4_source =
            "RULE MinimumWage WHEN employee IS workman THEN Employer MUST pay_minimum_wage";

        let result = converter.import_employment_act(l4_source);
        assert!(result.is_ok());

        let (statutes, _) = result.unwrap();
        for statute in statutes {
            assert_eq!(
                statute.effect.parameters.get("domain"),
                Some(&"employment".to_string())
            );
        }
    }

    #[test]
    fn test_pdpa_converter() {
        let mut converter = PdpaConverter::new();

        let l4_source = "RULE DataConsent WHEN personal_data IS collected THEN Organisation MUST obtain_consent";

        let result = converter.import_pdpa(l4_source);
        assert!(result.is_ok());

        let (statutes, _) = result.unwrap();
        for statute in statutes {
            assert_eq!(
                statute.effect.parameters.get("domain"),
                Some(&"data_protection".to_string())
            );
        }
    }

    #[test]
    fn test_cpfta_converter() {
        let mut converter = ConsumerProtectionConverter::new();

        let l4_source =
            "RULE FairTrading WHEN trader IS supplier THEN Trader SHANT engage_unfair_practice";

        let result = converter.import_cpfta(l4_source);
        assert!(result.is_ok());

        let (statutes, _) = result.unwrap();
        for statute in statutes {
            assert_eq!(
                statute.effect.parameters.get("domain"),
                Some(&"consumer_protection".to_string())
            );
        }
    }

    #[test]
    fn test_generate_l4_rule() {
        let rule = generate_l4_rule("voting_age", "age >= 21", "Person", "MAY", "vote");

        assert!(rule.contains("RULE VotingAge"));
        assert!(rule.contains("WHEN age >= 21"));
        assert!(rule.contains("THEN Person MAY vote"));
    }

    #[test]
    fn test_generate_l4_define() {
        let define = generate_l4_define("adult", "person whose age >= 21");

        assert!(define.contains("DEFINE Adult"));
        assert!(define.contains("MEANS person whose age >= 21"));
    }

    #[test]
    fn test_generate_l4_given() {
        let given = generate_l4_given(
            "employee_contract",
            &[("salary", "Money"), ("hours", "Number")],
            &[("eligible", "Boolean")],
        );

        assert!(given.contains("GIVEN EmployeeContract"));
        assert!(given.contains("salary IS A Money"));
        assert!(given.contains("GIVETH"));
        assert!(given.contains("eligible IS A Boolean"));
    }

    #[test]
    fn test_generate_l4_decide() {
        let decide = generate_l4_decide(
            "tax_rate",
            &[("income > 320000", "22%"), ("income > 160000", "15%")],
            "0%",
        );

        assert!(decide.contains("DECIDE tax_rate"));
        assert!(decide.contains("IF income > 320000 THEN 22%"));
        assert!(decide.contains("OTHERWISE 0%"));
    }

    #[test]
    fn test_to_l4_identifier() {
        assert_eq!(to_l4_identifier("voting_age"), "VotingAge");
        assert_eq!(to_l4_identifier("companies-act-s157"), "CompaniesActS157");
        assert_eq!(to_l4_identifier("TestCase"), "TestCase");
    }

    #[test]
    fn test_batch_import_l4() {
        let sources = vec![
            "RULE Test1 WHEN age >= 21 THEN Person MAY vote".to_string(),
            "RULE Test2 WHEN role = director THEN Director MUST disclose".to_string(),
        ];

        let result = batch_import_l4(&sources);
        assert!(result.is_ok());

        let results = result.unwrap();
        assert_eq!(results.len(), 2);
    }

    #[test]
    fn test_l4_deontic_operators() {
        assert_eq!(L4DeonticOperator::Must.keyword(), "MUST");
        assert_eq!(L4DeonticOperator::May.keyword(), "MAY");
        assert_eq!(L4DeonticOperator::Shant.keyword(), "SHANT");

        let op = L4DeonticOperator::from_effect_type(EffectType::Obligation);
        assert_eq!(op, L4DeonticOperator::Must);
    }

    #[test]
    fn test_convert_from_l4() {
        let mut converter = SingaporeL4Converter::new();

        let l4_source = "RULE Test WHEN age >= 21 THEN Person MAY act";

        let result = converter.convert_from_l4(l4_source, LegalFormat::Catala);
        assert!(result.is_ok());

        let (output, _) = result.unwrap();
        assert!(output.contains("declaration scope"));
    }
}
